local Byte         = string.byte; local Char         = string.char; local Sub          = string.sub; local Concat       = table.concat; local LDExp        = math.ldexp; local GetFEnv      = getfenv or function() return _ENV end; local Setmetatable = setmetatable; local Select       = select;  local Unpack = unpack; local ToNumber = tonumber;local function decompress(b)local c,d,e="","",{}local f=256;local g={}for h=0,f-1 do g[h]=Char(h)end;local i=1;local function k()local l=ToNumber(Sub(b, i,i),36)i=i+1;local m=ToNumber(Sub(b, i,i+l-1),36)i=i+l;return m end;c=Char(k())e[1]=c;while i<#b do local n=k()if g[n]then d=g[n]else d=c..Sub(c, 1,1)end;g[f]=c..Sub(d, 1,1)e[#e+1],c,f=d,d,f+1 end;return table.concat(e)end;local ByteString=decompress('26X24127521N24922P2321124927521R23L2791423L27521Q24924H2411427C24121724X27G24X2751Y27U27N27X1Z24H27G27M2411Y2831428328527I2872751R25527G2552751V28123228B2411U2612692411H2612751J28J21M2831I25D1H27N25D2751M27527N2951B26127G28S2411F25D27G2922411325L27G25L2751827S28K27U1H23E29G21N29G23I26H27629X24123E23L27U21427I2411M29X2401J29Z1M1H22P2411J2902411822H23223221I2AK26M1B26P27921E26P2751F29J23221E29L241122831M283172AX2AZ2751C24922R2322112492431H23I1H1X24121F2AH23I1P21T24121W1P2752BO2BK142BT24123625T275142C124123A24P2C22C724122Y29B1429B23228628322Q2AH142AH22U2CJ2AH22Y24X27U1427X22Y25L25T240142B023229B21N29B22Q2AU2411Q2D522U2BY2BX27522I2DA2BY2322CQ27Y27523225L25D2CX2B022U21D2C22DQ24122I21L2C22DV24122V21527G21527522U2E227N2E52E428A2E522N2B72B022B2992AY29B1T2492692401827C1H21K2951A2752EO26H2791A29X1H1T2691H2401L28P2EO26X2EV2741H22E2152352B12E52222292FC1222927522D2492292401U2EN2EP2752ER28Q2EP2EV2ES22A21T112401R2BQ2412262151X2401Y2E522623D2FC1I23D27521U2292FN142FJ24121U22P2FC142AE24122M22H2GP22H2DC2GR2GQ2E32GF27N2H121K26P2AL142H526M22T2492F12BA2FU2EQ2ES2FV2322FT1H22U2GL21N2GL2EI2EK2EM2HE2FS2HG2EF1A28S2F92FB2FD2752EI2G72HR2EO2HF2HE2FW28Q2FY2G02G22752222G62G82FE2352FC1E2FC2GS2GU27Q2GW24122U2IL21N2IL21K112AL1A2IW26M23A2G321N2G322Y2212762J62B129521Q29521K22X24E2411A22X2322J025L24H24021C2B01Q112JM21J112B92352302AM2JW26M21I2C421N2C42162D129B2162JA2JC2JE2JG2JI26M21Q23T27521O2KG24121M24127U21B29521M24927I21R27P2KQ2751527P24124F29524024B29527127226O26T26A26D26B26W27326U24024529526U26O27026S24024629526126D26D26925Y26S26D24025V29526Y1522N23127025G24G21C2651026D1D21621923621721V1X22821522U21A21A2532DK25V1121M24L1625Q21R2731O21K2111I24M26N23U26Y1B23R21J2501U23L22Y21626L24J23O21224525H27023Y21X21C24S26I22827221K122402952412402472952L92LB2LD2402422NX26C26R2LF29526Q26X26O26B2432NT2NT2OC2NT23527225T2OF2NT22P24U24025X2952422352171T23Z27223Z1V24V22P2421Z22521W1621V21I21V21122I1322K2252601025925223322623V22T24H22A25S23622922621124F26225A25X22G26Q22B26321Y25P1522323T25I26U1926W24K24526822Y22R26123Y21R24Y23121V23I1A2OK29525C2OJ2OD2752C4275'); 			 local BitXOR = bit and bit.bxor or function(a,b)     local p,c=1,0     while a>0 and b>0 do         local ra,rb=a%2,b%2         if ra~=rb then c=c+p end         a,b,p=(a-ra)/2,(b-rb)/2,p*2     end     if a<b then a=b end     while a>0 do         local ra=a%2         if ra>0 then c=c+p end         a,p=(a-ra)/2,p*2     end     return c end  local function gBit(Bit, Start, End) 	if End then 		local Res = (Bit / 2 ^ (Start - 1)) % 2 ^ ((End - 1) - (Start - 1) + 1);  		return Res - Res % 1; 	else 		local Plc = 2 ^ (Start - 1);          return (Bit % (Plc + Plc) >= Plc) and 1 or 0; 	end; end;  local Pos = 1;  local function gBits32()     local W, X, Y, Z = Byte(ByteString, Pos, Pos + 3);  	W = BitXOR(W, 145) 	X = BitXOR(X, 145) 	Y = BitXOR(Y, 145) 	Z = BitXOR(Z, 145)      Pos	= Pos + 4;     return (Z*16777216) + (Y*65536) + (X*256) + W; end;  local function gBits8()     local F = BitXOR(Byte(ByteString, Pos, Pos), 145);     Pos = Pos + 1;     return F; end;  local function gFloat() 	local Left = gBits32(); 	local Right = gBits32(); 	local IsNormal = 1; 	local Mantissa = (gBit(Right, 1, 20) * (2 ^ 32)) 					+ Left; 	local Exponent = gBit(Right, 21, 31); 	local Sign = ((-1) ^ gBit(Right, 32)); 	if (Exponent == 0) then 		if (Mantissa == 0) then 			return Sign * 0; 		else 			Exponent = 1; 			IsNormal = 0; 		end; 	elseif (Exponent == 2047) then         return (Mantissa == 0) and (Sign * (1 / 0)) or (Sign * (0 / 0)); 	end; 	return LDExp(Sign, Exponent - 1023) * (IsNormal + (Mantissa / (2 ^ 52))); end;  local gSizet = gBits32; local function gString(Len)     local Str;     if (not Len) then         Len = gSizet();         if (Len == 0) then             return '';         end;     end;      Str	= Sub(ByteString, Pos, Pos + Len - 1);     Pos = Pos + Len;  	local FStr = {} 	for Idx = 1, #Str do 		FStr[Idx] = Char(BitXOR(Byte(Sub(Str, Idx, Idx)), 145)) 	end      return Concat(FStr); end;  local gInt = gBits32; local function _R(...) return {...}, Select('#', ...) end  local function Deserialize()     local Instrs = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };     local Functions = {  }; 	local Lines = {};     local Chunk =  	{ 		Instrs, 		nil, 		Functions, 		nil, 		Lines 	};for Idx=1,gBits32() do  									local Data1=BitXOR(gBits32(),171); 									local Data2=BitXOR(gBits32(),149);   									local Type=gBit(Data1,1,2); 									local Opco=gBit(Data2,1,11); 									 									local Inst= 									{ 										Opco, 										gBit(Data1,3,11), 										nil, 										nil, 										Data2 									};  									if (Type == 0) then Inst[3]=gBit(Data1,12,20);Inst[5]=gBit(Data1,21,29); 									elseif(Type==1) then Inst[3]=gBit(Data2,12,33); 									elseif(Type==2) then Inst[3]=gBit(Data2,12,32)-1048575; 									elseif(Type==3) then Inst[3]=gBit(Data2,12,32)-1048575;Inst[5]=gBit(Data1,21,29); 									end; 									 									Instrs[Idx]=Inst;end;Chunk[4] = gBits8(); 								local ConstCount = gBits32()     							local Consts = {0,0,0,0,0,0,0,0,0,0,0,0,0,0};  								for Idx=1,ConstCount do  									local Type=gBits8(); 									local Cons; 	 									if(Type==3) then Cons=(gBits8() ~= 0); 									elseif(Type==2) then Cons = gFloat(); 									elseif(Type==1) then Cons=gString(); 									end; 									 									Consts[Idx]=Cons; 								end; 								Chunk[2] = Consts 								for Idx=1,gBits32() do Functions[Idx-1]=Deserialize();end;return Chunk;end; local function Wrap(Chunk, Upvalues, Env) 	local Instr  = Chunk[1]; 	local Const  = Chunk[2]; 	local Proto  = Chunk[3]; 	local Params = Chunk[4];  	return function(...) 		local Instr  = Instr;  		local Const  = Const;  		local Proto  = Proto;  		local Params = Params;  		local _R = _R 		local InstrPoint = 1; 		local Top = -1;  		local Vararg = {}; 		local Args	= {...};  		local PCount = Select('#', ...) - 1;  		local Lupvals	= {}; 		local Stk		= {};  		for Idx = 0, PCount do 			if (Idx >= Params) then 				Vararg[Idx - Params] = Args[Idx + 1]; 			else 				Stk[Idx] = Args[Idx + 1]; 			end; 		end;  		local Varargsz = PCount - Params + 1  		local Inst; 		local Enum;	  		while true do 			Inst		= Instr[InstrPoint]; 			Enum		= Inst[1];if Enum <= 31 then if Enum <= 15 then if Enum <= 7 then if Enum <= 3 then if Enum <= 1 then if Enum == 0 then Stk[Inst[2]][Stk[Inst[3]]]=Stk[Inst[5]];else do return end;end; elseif Enum > 2 then Stk[Inst[2]]=Env[Const[Inst[3]]];else local A=Inst[2];local B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];end; elseif Enum <= 5 then if Enum > 4 then local B;local A;Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];else Stk[Inst[2]]=Const[Inst[3]];end; elseif Enum > 6 then if(Const[Inst[2]]<Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;else Stk[Inst[2]]=Stk[Inst[3]]%Const[Inst[5]];end; elseif Enum <= 11 then if Enum <= 9 then if Enum > 8 then Stk[Inst[2]]=Env[Const[Inst[3]]];else if(Stk[Inst[2]]>=Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;end; elseif Enum == 10 then Stk[Inst[2]]=Stk[Inst[3]]/Const[Inst[5]];else if(Stk[Inst[2]]>=Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;end; elseif Enum <= 13 then if Enum > 12 then Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[5]]];else if(Const[Inst[2]]>=Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;end; elseif Enum > 14 then local A=Inst[2];local Args={};local Edx=0;local Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;local Results={Stk[A](Unpack(Args,1,Limit-A))};local Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;else InstrPoint=InstrPoint+Inst[3];end; elseif Enum <= 23 then if Enum <= 19 then if Enum <= 17 then if Enum > 16 then if(Const[Inst[2]]<Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;else Stk[Inst[2]]();Top=A;end; elseif Enum > 18 then Stk[Inst[2]]=Stk[Inst[3]]+Stk[Inst[5]];else Stk[Inst[2]]=#Stk[Inst[3]];end; elseif Enum <= 21 then if Enum > 20 then Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];else local A=Inst[2];Stk[A]=Stk[A]-Stk[A+2];InstrPoint=InstrPoint+Inst[3];end; elseif Enum > 22 then Stk[Inst[2]][Stk[Inst[3]]]=Stk[Inst[5]];else Stk[Inst[2]]=Stk[Inst[3]]/Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]/Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]*Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=InstrPoint+Inst[3];end; elseif Enum <= 27 then if Enum <= 25 then if Enum == 24 then Stk[Inst[2]]=Stk[Inst[3]]/Const[Inst[5]];else local A=Inst[2];local B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];end; elseif Enum == 26 then if(Stk[Inst[2]]==Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;else Stk[Inst[2]]={};end; elseif Enum <= 29 then if Enum == 28 then Stk[Inst[2]]={};else Stk[Inst[2]]=Stk[Inst[3]]+Const[Inst[5]];end; elseif Enum == 30 then local Results;local Limit;local Edx;local Args;local A;Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];else Stk[Inst[2]]=Stk[Inst[3]]+Stk[Inst[5]];end; elseif Enum <= 47 then if Enum <= 39 then if Enum <= 35 then if Enum <= 33 then if Enum > 32 then local A=Inst[2];Stk[A]=Stk[A]-Stk[A+2];InstrPoint=InstrPoint+Inst[3];else if(Const[Inst[2]]>=Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;end; elseif Enum == 34 then Stk[Inst[2]]=Stk[Inst[3]];else local A=Inst[2];local Args={};local Edx=0;local Limit=Top;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;local Results={Stk[A](Unpack(Args,1,Limit-A))};local Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;end; elseif Enum <= 37 then if Enum == 36 then local A=Inst[2];local Step=Stk[A+2];local Index=Stk[A]+Step;Stk[A]=Index;if Step>0 then if Index<=Stk[A+1] then InstrPoint=InstrPoint+Inst[3];Stk[A+3]=Index;end;elseif Index>=Stk[A+1] then InstrPoint=InstrPoint+Inst[3];Stk[A+3]=Index;end;else Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];end; elseif Enum > 38 then InstrPoint=InstrPoint+Inst[3];else Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[5]];end; elseif Enum <= 43 then if Enum <= 41 then if Enum > 40 then local A=Inst[2];local Args={};local Edx=0;local Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;local Results,Limit=_R(Stk[A](Unpack(Args,1,Limit-A)));Limit=Limit+A-1;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;else Stk[Inst[2]]=Stk[Inst[3]]%Const[Inst[5]];end; elseif Enum == 42 then do return end;else local A=Inst[2];local Args={};local Edx=0;local Limit=Top;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;local Results={Stk[A](Unpack(Args,1,Limit-A))};local Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;end; elseif Enum <= 45 then if Enum > 44 then Stk[Inst[2]]=Stk[Inst[3]]*Const[Inst[5]];else local A=Inst[2];local Args={};local Edx=0;local Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;local Results={Stk[A](Unpack(Args,1,Limit-A))};local Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;end; elseif Enum == 46 then Stk[Inst[2]]=Stk[Inst[3]]-Const[Inst[5]];else Stk[Inst[2]]=Stk[Inst[3]]*Const[Inst[5]];end; elseif Enum <= 55 then if Enum <= 51 then if Enum <= 49 then if Enum == 48 then local B=Inst[3];local K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;else Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[5]];end; elseif Enum > 50 then local B=Inst[3];local K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;else local A=Inst[2];local Step=Stk[A+2];local Index=Stk[A]+Step;Stk[A]=Index;if Step>0 then if Index<=Stk[A+1] then InstrPoint=InstrPoint+Inst[3];Stk[A+3]=Index;end;elseif Index>=Stk[A+1] then InstrPoint=InstrPoint+Inst[3];Stk[A+3]=Index;end;end; elseif Enum <= 53 then if Enum == 52 then Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[5]]];else if(Stk[Inst[2]]==Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;end; elseif Enum == 54 then Stk[Inst[2]]=Const[Inst[3]];else Stk[Inst[2]]=Stk[Inst[3]]-Const[Inst[5]];end; elseif Enum <= 59 then if Enum <= 57 then if Enum > 56 then Stk[Inst[2]]=Stk[Inst[3]]+Const[Inst[5]];else local A=Inst[2];local Args={};local Edx=0;local Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;local Results,Limit=_R(Stk[A](Unpack(Args,1,Limit-A)));Limit=Limit+A-1;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;end; elseif Enum > 58 then Stk[Inst[2]]();Top=A;else Top=Inst[2];end; elseif Enum <= 61 then if Enum == 60 then Stk[Inst[2]]=#Stk[Inst[3]];else Top=Inst[2];end; elseif Enum <= 62 then local A;Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Stk[A]=Stk[A]-Stk[A+2];InstrPoint=InstrPoint+Inst[3]; elseif Enum == 63 then Stk[Inst[2]]=Stk[Inst[3]];else local Results;local Limit;local Edx;local Args;local A;Stk[Inst[2]]=Stk[Inst[3]]%Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]+Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[5]]];end; 			InstrPoint	= InstrPoint + 1; 		end;     end; end;	 return Wrap(Deserialize(), {}, GetFEnv())(); 
